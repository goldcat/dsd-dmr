#include <stdint.h>
#include <math.h>
#include "dsd.h"

// DMR filter
// Filter details ..
// filtertype	 =	 Raised Cosine
// samplerate	 =	 48000
// corner	 =	 2400
// beta	 =	 0.2 
// impulselen	 =	 81
// racos	 =	 sqrt
// comp	 =	 no

float ngain = 0.101333437f;
static float xcoeffs[84] = {
    +0.0273676736, +0.0190682959, +0.0070661879, -0.0075385898,
    -0.0231737159, -0.0379433607, -0.0498333862, -0.0569528373,
    -0.0577853377, -0.0514204905, -0.0377352004, -0.0174982391,
    +0.0076217868, +0.0351552125, +0.0620353691, +0.0848941519,
    +0.1004237235, +0.1057694293, +0.0989127431, +0.0790009892,
    +0.0465831968, +0.0037187043, -0.0460635022, -0.0979622825,
    -0.1462501260, -0.1847425896, -0.2073523972, -0.2086782295,
    -0.1845719273, -0.1326270847, -0.0525370892, +0.0537187153,
    +0.1818868577, +0.3256572849, +0.4770745929, +0.6271117870,
    +0.7663588857, +0.8857664963, +0.9773779594, +1.0349835419,
    +1.0546365475, +1.0349835419, +0.9773779594, +0.8857664963,
    +0.7663588857, +0.6271117870, +0.4770745929, +0.3256572849,
    +0.1818868577, +0.0537187153, -0.0525370892, -0.1326270847,
    -0.1845719273, -0.2086782295, -0.2073523972, -0.1847425896,
    -0.1462501260, -0.0979622825, -0.0460635022, +0.0037187043,
    +0.0465831968, +0.0790009892, +0.0989127431, +0.1057694293,
    +0.1004237235, +0.0848941519, +0.0620353691, +0.0351552125,
    +0.0076217868, -0.0174982391, -0.0377352004, -0.0514204905,
    -0.0577853377, -0.0569528373, -0.0498333862, -0.0379433607,
    -0.0231737159, -0.0075385898, +0.0070661879, +0.0190682959,
    +0.0273676736, 0.0, 0.0, 0.0
};

// NXDN filter
float nxgain = 0.062659371644565f;

static float nxcoeffs[] = {
  +0.031462429, +0.031747267, +0.030401148, +0.027362877,
  +0.022653298, +0.016379869, +0.008737200, +0.000003302,
  -0.009468531, -0.019262057, -0.028914291, -0.037935027,
  -0.045828927, -0.052119261, -0.056372283, -0.058221106,
  -0.057387924, -0.053703443, -0.047122444, -0.037734535,
  -0.025769308, -0.011595336, +0.004287292, +0.021260954,
  +0.038610717, +0.055550276, +0.071252765, +0.084885375,
  +0.095646450, +0.102803611, +0.105731303, +0.103946126,
  +0.097138329, +0.085197939, +0.068234131, +0.046586711,
  +0.020828821, -0.008239664, -0.039608255, -0.072081234,
  -0.104311776, -0.134843790, -0.162160200, -0.184736015,
  -0.201094346, -0.209863285, -0.209831516, -0.200000470,
  -0.179630919, -0.148282051, -0.105841323, -0.052543664,
  +0.011020985, +0.083912428, +0.164857408, +0.252278939,
  +0.344336996, +0.438979335, +0.534000832, +0.627109358,
  +0.715995947, +0.798406824, +0.872214756, +0.935487176,
  +0.986548646, +1.024035395, +1.046939951, +1.054644241,
  +1.046939951, +1.024035395, +0.986548646, +0.935487176,
  +0.872214756, +0.798406824, +0.715995947, +0.627109358,
  +0.534000832, +0.438979335, +0.344336996, +0.252278939,
  +0.164857408, +0.083912428, +0.011020985, -0.052543664,
  -0.105841323, -0.148282051, -0.179630919, -0.200000470,
  -0.209831516, -0.209863285, -0.201094346, -0.184736015,
  -0.162160200, -0.134843790, -0.104311776, -0.072081234,
  -0.039608255, -0.008239664, +0.020828821, +0.046586711,
  +0.068234131, +0.085197939, +0.097138329, +0.103946126,
  +0.105731303, +0.102803611, +0.095646450, +0.084885375,
  +0.071252765, +0.055550276, +0.038610717, +0.021260954,
  +0.004287292, -0.011595336, -0.025769308, -0.037734535,
  -0.047122444, -0.053703443, -0.057387924, -0.058221106,
  -0.056372283, -0.052119261, -0.045828927, -0.037935027,
  -0.028914291, -0.019262057, -0.009468531, +0.000003302,
  +0.008737200, +0.016379869, +0.022653298, +0.027362877,
  +0.030401148, +0.031747267, +0.031462429, 0.0 
};

#if defined(__amd64__) || defined(__x86_64__) || defined(__i386__) && defined(__SSE__)
static float scalarproduct_float_sse(float *v1, float *v2, unsigned int len) {
        float sum = 0.0f;
        unsigned int i;

        for(i=0; i<len; i+=4) {
            __asm__ volatile(
                 "movups  (%1), %%xmm2 \n\t"
                 "movaps  (%2), %%xmm3 \n\t"
                 "mulps %%xmm3, %%xmm2 \n\t"
                 "addps %%xmm2, %0 \n\t"
                :"=x"(sum) :"r"(&v1[i]), "r"(&v2[i]));
        }
        __asm__ volatile(
                 "movaps      %0, %%xmm5 \n\t"
                 "shufps   $0x1b, %0, %%xmm5 \n\t"
                 "addps       %0, %%xmm5 \n\t"
                 "movhlps %%xmm5, %0     \n\t"
                 "addps   %%xmm5, %0     \n\t"
                :"+x"(sum));
        return sum;
}
#define scalarproduct_float scalarproduct_float_sse
#elif defined(__ARM_NEON__)
static float scalarproduct_float_neon(float *a, float *b, unsigned int len)
{
    float ret = 0.0f;
    uint32_t remainder = (len & 15);
    len -= remainder;

    __asm__ __volatile("  vmov.f32 q1, #0.0\n"
                       "  cmp %[len], #0\n"
                       "  bne 1f\n"
                       "  b 2f\n"
                       "1:"
                       "  vld1.32 {q8, q9}, [%[b]]!\n"
                       "  vld1.32 {q12, q13}, [%[a]]!\n"
                       "  vld1.32 {q10, q11}, [%[b]]!\n"
                       "  vld1.32 {q14, q15}, [%[a]]!\n"
                       "  vmla.f32 q1, q8, q12\n"
                       "  vmla.f32 q1, q9, q13\n"
                       "  vmla.f32 q1, q10, q14\n"
                       "  vmla.f32 q1, q11, q15\n"
                       "  subs %[len], %[len], #16\n"
                       "  bne 1b\n"
                       "  cmp %[remainder], #0\n"
                       "  beq 3f\n"
                       "2:"
                       "  vld1.32 {q2}, [%[b]]!\n"
                       "  vld1.32 {q3}, [%[a]]!\n"
                       "  vmla.f32 q1, q2, q3\n"
                       "  subs %[remainder], %[remainder], #4\n"
                       "  bne 2b\n"
                       "2:"
                       "  vadd.f32 d2, d2, d3\n"
                       "  vpadd.f32 d2, d2, d2\n"
                       "  vmov.f32 %[ret], d2[0]\n"
                       : [ret] "=&r" (ret), [a] "+r" (a), [b] "+r" (b),
                         [len] "+l" (len), [remainder] "+l" (remainder)
                       :
                       : "cc", "q1", "q2", "q3", "q8", "q9", "q10", "q11",
                               "q12", "q13", "q14", "q15");
    return ret;
}
#define scalarproduct_float scalarproduct_float_neon
#else
static float scalarproduct_float_c(float *v1, float *v2, unsigned int len)
{
    float p = 0.0f;
    unsigned int i;
    for (i = 0; i < len; i++) {
        p += v1[i] * v2[i];
    }
    return p;
}
#define scalarproduct_float scalarproduct_float_c
#endif

float
dmr_filter(dsd_state *state, float sample)
{
  float sum = 0.0f;
  unsigned int i;

  for (i = 0; i < RRC_NZEROS; i++)
    state->xv[i] = state->xv[i+1];

  state->xv[RRC_NZEROS] = sample; // unfiltered sample in
  sum = scalarproduct_float(state->xv, xcoeffs, 84);
  return (sum * ngain); // filtered sample out
}

float
nxdn_filter(dsd_state *state, float sample)
{
  float sum = 0.0f;
  unsigned int i;

  for (i = 0; i < RRC_NXZEROS; i++)
    state->xv[i] = state->xv[i+1];

  state->xv[RRC_NXZEROS] = sample; // unfiltered sample in
  sum = scalarproduct_float(state->xv, nxcoeffs, 136);
  return (sum * nxgain); // filtered sample out
}

